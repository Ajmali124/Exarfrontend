// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model User {
  id            String    @id
  name          String    @db.Text
  email         String
  username      String?   @unique
  emailVerified Boolean   @default(false)
  image         String?   @db.Text
  inviteCode    String?   @unique
  avatarFrame   String?   @db.Text
  nickname      String?   @db.Text
  gender        String?   @db.Text
  homepage      String?   @db.Text
  location      String?   @db.Text
  linkEmail     String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @default(now()) @updatedAt
  sessions      Session[]
  accounts      Account[]


  // Relations
  userBalances    UserBalance[]
  invitedMembers  InvitedMember[] @relation("Sponsor")
  inviteeRecords  InvitedMember[] @relation("Invitee")
  transactions    TransactionRecord[]
  stakingEntries  StakingEntry[]
  teamRewardRecords TeamEarningRecord[] @relation("TeamEarningRecipient")
  teamRewardSources TeamEarningRecord[] @relation("TeamEarningSource")
  coinpaymentsDepositAddress CoinpaymentsDepositAddress?
  vouchers Voucher[]
  promotionRegistrations PromotionRegistration[]
  gridBots        GridBot[]
  dcaBots         DCABot[]
  kycSubmission KycSubmission?
  
  @@unique([email])
  @@map("user")
  
}

model KycSubmission {
  id String @id @default(uuid())
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique

  // Basic KYC
  basicStatus String @default("not_submitted") // 'not_submitted' | 'submitted' | 'approved' | 'rejected'
  fullName String? @db.Text
  address String? @db.Text
  selfieImageUrl String? @db.Text
  basicSubmittedAt DateTime?
  basicReviewedAt DateTime?
  basicReviewNote String? @db.Text

  // Advanced KYC
  advancedStatus String @default("not_submitted") // 'not_submitted' | 'submitted' | 'approved' | 'rejected'
  documentType String? @db.Text // 'passport' | 'id_card'
  documentFrontUrl String? @db.Text
  documentBackUrl String? @db.Text
  advancedSubmittedAt DateTime?
  advancedReviewedAt DateTime?
  advancedReviewNote String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([basicStatus])
  @@index([advancedStatus])
  @@map("kyc_submission")
}

model InvitedMember {
  id        String @id @default(uuid())
  sponsor   User   @relation("Sponsor", fields: [sponsorId], references: [id], onDelete: Cascade)
  invitee   User   @relation("Invitee", fields: [userId], references: [id], onDelete: Cascade)

  sponsorId String // The user who did the inviting
  userId    String // The user who was invited
  firstName String
  lastName  String
  email     String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sponsorId])
  @@index([userId])
  @@map("invited_member")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?  @db.Text
  userAgent String?  @db.Text
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
  @@index([userId])
}

model Account {
  id                    String    @id
  accountId             String    @db.Text
  providerId            String    @db.Text
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?   @db.Text
  password              String?   @db.Text
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
  @@index([userId])
}

model Verification {
  id         String   @id
  identifier String   @db.Text
  value      String   @db.Text
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model UserBalance {
  id   String @id @default(uuid())
  user User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  userId              String @unique
  balance             Float  @default(0)
  demoBalance         Float  @default(0) 
  onStaking           Float  @default(0)
  maxEarn             Float  @default(0)
  dailyEarning        Float  @default(0)
  teamEarning         Float  @default(0)
  earningWithdraw     Float  @default(0)
  latestEarning       Float  @default(0)
  teamEarningWithdraw Float  @default(0)
  missedEarnings      Float  @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("user_balance")
}

model TransactionRecord {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  
  type        String   // 'deposit', 'withdrawal', 'transfer', 'reward', etc.
  amount      Float
  currency    String   @default("USDT")
  status      String   // 'pending', 'completed', 'failed', 'cancelled'
  description String?  @db.Text
  
  // Optional fields for tracking
  transactionHash String? @db.Text
  fromAddress     String? @db.Text
  toAddress       String? @db.Text
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@map("transaction_record")
}

model TeamEarningRecord {
  id           String   @id @default(uuid())
  user         User     @relation("TeamEarningRecipient", fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  sourceUser   User?    @relation("TeamEarningSource", fields: [sourceUserId], references: [id], onDelete: Cascade)
  sourceUserId String?
  level        Int
  amount       Float
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([sourceUserId])
  @@map("team_earning_record")
}

model StakingEntry {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  
  // Package information
  packageName String   // e.g., 'Bronze Node', 'Silver Node', etc.
  packageId   Int      // Package ID (1-7)
  
  amount      Float
  currency    String   @default("USDT")
  
  // ROI and cap tracking
  dailyROI    Float    // Daily ROI percentage (e.g., 0.8 for 0.8%)
  cap         Float    // Maximum earning multiplier (e.g., 1.8 for 180%)
  maxEarning  Float    // Maximum earning = amount * cap
  totalEarned Float    @default(0) // Total earned so far
  
  // Status tracking
  status      String   @default("active") // 'active', 'unstaking', 'completed', 'cancelled'
  
  // Dates
  startDate   DateTime @default(now())
  unstakeRequestedDate DateTime? // When user requested unstake
  cooldownEndDate DateTime?      // When cooldown ends (3 days after unstake request)
  endDate     DateTime?          // When stake was completed
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([startDate])
  @@index([packageId])
  @@map("staking_entry")
}

model CoinpaymentsDepositAddress {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String   @unique
  label      String   @unique
  address    String   @db.Text
  payCurrency String  @default("usdtbep20")
  paymentId  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId])
  @@map("coinpayments_deposit_address")
}

model Voucher {
  id          String   @id @default(uuid())
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String?
  
  // Voucher identification
  code        String?  @unique // Optional redemption code (for manual vouchers)
  
  // Voucher value and currency
  value       Float    // Voucher value/amount
  currency    String   @default("USDT")
  
  // Voucher type: 'package' (for buying staking packages), 'withdraw' (instant withdrawable), 'futures' (futures position), 'bonus' (general bonus)
  type        String   // 'package', 'withdraw', 'futures', 'bonus', 'trading_fee'
  
  // Display information
  title       String   // e.g., "Futures Position", "Staking Bonus", "Instant Withdrawal"
  badge       String?  // e.g., "Position Voucher", "Package Voucher", "Withdrawal Voucher"
  badgeColor  String?  @default("orange") // 'orange', 'blue', 'green', 'purple'
  description String?  @db.Text // e.g., "The position will close automatically after 1D.; Up to 5x Leverage"
  linkText    String?  @db.Text // e.g., "Designated pairs in Futures"
  linkHref    String?  @db.Text // Optional link URL
  
  // Package-specific (if type is 'package')
  packageId   Int?     // If voucher is for specific staking package
  packageName String?  // Package name for display
  
  // ROI validity for package vouchers (in days)
  roiValidityDays Int? // Number of days voucher provides ROI (3, 7, 14, 30 days)
  roiEndDate      DateTime? // When voucher's ROI period ends (calculated from usedAt)
  appliedToStakeId String? // Link to staking entry if voucher is applied to a stake
  affectsMaxCap    Boolean @default(false) // Whether voucher has its own max cap (true = independent max cap, false = no max cap)
  requiresRealPackage Boolean @default(false) // If true, voucher only works if user has purchased a real package (ROI is flushed without real package)
  
  // Status: 'active', 'used', 'expired', 'cancelled'
  status      String   @default("active")
  
  // Dates
  expiresAt   DateTime // Expiry date for the voucher (redemption deadline)
  usedAt      DateTime? // When voucher was used
  usedOnPackageId Int? // If used for package, track which package
  
  // Transaction tracking (if used)
  transactionId String? // Link to transaction record if voucher was redeemed
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([expiresAt])
  @@index([code])
  @@index([createdAt])
  @@map("voucher")
}

model PromotionRegistration {
  id            String   @id @default(uuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String   @unique // One registration per user per promotion
  
  promotionType String   @default("prelaunch") // Type of promotion
  registeredAt  DateTime @default(now())
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
  @@index([promotionType])
  @@index([registeredAt])
  @@map("promotion_registration")
}


model GridBot {
  id              String   @id @default(uuid())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  // Basic Configuration
  name            String?  @db.Text // Optional bot name
  symbol          String   // Trading pair (e.g., SOLUSD, BTCUSD)
  accountType     String   @default("DEMO") // DEMO or REAL
  status          String   @default("stopped") // active, paused, stopped
  
  // Investment
  investment      Float    // Investment amount in lots
  margin          Float    // Calculated margin
  
  // AI Preset
  aiPreset        String   @default("Optimal") // Conservative, Optimal, Aggressive
  
  // Grid Configuration
  upperPrice      Float    // High price bound
  lowerPrice      Float    // Low price bound
  gridLevels      Int      // Number of grid levels
  gridSpacing     Float    // Calculated spacing between levels
  orderAmountPerLevel Float // Investment per grid level
  
  // Price Units (for frontend display)
  upperPriceUnit  String   @default("price") // price or percent
  lowerPriceUnit  String   @default("price") // price or percent
  gridLevelsUnit  String   @default("levels") // levels or percent
  
  // Trading Filters
  totalTargetProfit    Float?  // Auto-stop profit target
  allowableTotalLoss   Float?  // Auto-stop loss limit
  maxPrice             Float?  // Maximum execution price
  minPrice             Float?  // Minimum execution price
  
  // Performance Tracking
  totalProfit          Float   @default(0)
  totalProfitPercent   Float   @default(0)
  totalPL              Float   @default(0) // Total P/L
  totalPLPercent       Float   @default(0)
  currentPrice         Float?  // Last known price
  
  // Balances (demo trading)
  baseBalance          Float   @default(0) // Base currency (e.g., USDT)
  quoteBalance         Float   @default(0) // Quote currency (e.g., BTC)
  
  // Timestamps
  startedAt            DateTime?
  stoppedAt            DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  // Relations
  orders               GridBotOrder[]
  executions           GridBotExecution[]
  
  @@index([userId])
  @@index([status])
  @@index([symbol])
  @@index([createdAt])
  @@map("grid_bot")
}

model GridBotOrder {
  id              String   @id @default(uuid())
  bot             GridBot  @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId           String
  
  // Order Details
  orderType       String   // BUY or SELL
  gridLevel       Int      // Which grid level this order belongs to
  price           Float    // Order price
  quantity        Float    // Order quantity (in lots or base currency)
  status          String   @default("PENDING") // PENDING, FILLED, CANCELLED
  
  // Execution Details
  filledPrice     Float?
  filledQuantity  Float?
  filledAt        DateTime?
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  executions      GridBotExecution[]
  
  @@index([botId])
  @@index([status])
  @@index([gridLevel])
  @@map("grid_bot_order")
}

model GridBotExecution {
  id              String   @id @default(uuid())
  bot             GridBot  @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId           String
  order           GridBotOrder? @relation(fields: [orderId], references: [id])
  orderId         String?
  
  // Execution Details
  executionType   String   // BUY or SELL
  price           Float    // Execution price
  quantity        Float    // Executed quantity
  fee             Float    @default(0) // Trading fee (for future use)
  
  // Profit Tracking
  profit          Float    @default(0) // Profit from this execution
  cumulativeProfit Float   @default(0) // Total profit up to this execution
  
  // Position Tracking
  baseBalanceAfter  Float   // Base balance after execution
  quoteBalanceAfter Float   // Quote balance after execution
  
  timestamp       DateTime @default(now())
  
  @@index([botId])
  @@index([timestamp])
  @@map("grid_bot_execution")
}

model DCABot {
  id              String   @id @default(uuid())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  
  // Basic Configuration
  name            String?  @db.Text // Optional bot name
  symbol          String   // Trading pair (e.g., SOLUSD, BTCUSD)
  accountType     String   @default("DEMO") // DEMO or REAL
  status          String   @default("stopped") // active, paused, stopped
  position        String   @default("Long") // Long or Short
  
  // Investment
  investment      Float    // Investment amount in lots
  margin          Float    // Calculated margin
  
  // AI Preset
  aiPreset        String   @default("Optimal") // Conservative, Optimal, Aggressive
  
  // DCA Configuration
  initialOrderAmount Float  // Initial order amount
  extraOrderAmount  Float   // Extra order amount
  extraOrders       Int     // Number of extra orders
  extraOrdersStep   Float   // Step between extra orders
  extraOrdersStepUnit String @default("pips") // pips or percent
  amountMultiplier   Float  @default(1.0) // Amount multiplier
  stepMultiplier     Float  @default(1.0) // Step multiplier
  entryCondition     String @default("instantly") // instantly, rsi, cci, etc.
  
  // Take Profit & Stop Loss
  takeProfit      Float?   // Take profit value
  takeProfitUnit  String?  @default("pips") // pips or percent
  stopLoss        Float?   // Stop loss value
  stopLossUnit    String?  @default("pips") // pips or percent
  stopLossEnabled Boolean  @default(false)
  
  // Trading Filters
  totalTargetProfit    Float?  // Auto-stop profit target
  allowableTotalLoss   Float?  // Auto-stop loss limit
  maxPrice             Float?  // Maximum execution price
  minPrice             Float?  // Minimum execution price
  
  // Performance Tracking
  totalProfit          Float   @default(0)
  totalProfitPercent   Float   @default(0)
  totalPL              Float   @default(0) // Total P/L
  totalPLPercent       Float   @default(0)
  currentPrice         Float?  // Last known price
  
  // Balances (demo trading)
  baseBalance          Float   @default(0) // Base currency (e.g., USDT)
  quoteBalance         Float   @default(0) // Quote currency (e.g., BTC)
  
  // Timestamps
  startedAt            DateTime?
  stoppedAt            DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  
  // Relations
  orders               DCABotOrder[]
  executions           DCABotExecution[]
  
  @@index([userId])
  @@index([status])
  @@index([symbol])
  @@index([createdAt])
  @@map("dca_bot")
}

model DCABotOrder {
  id              String   @id @default(uuid())
  bot             DCABot  @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId           String
  
  // Order Details
  orderType       String   // BUY or SELL
  orderNumber     Int      // Order number in sequence (1, 2, 3, ...)
  price           Float    // Order price
  quantity        Float    // Order quantity (in lots or base currency)
  status          String   @default("PENDING") // PENDING, FILLED, CANCELLED
  
  // Execution Details
  filledPrice     Float?
  filledQuantity  Float?
  filledAt        DateTime?
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  executions      DCABotExecution[]
  
  @@index([botId])
  @@index([status])
  @@index([orderNumber])
  @@map("dca_bot_order")
}

model DCABotExecution {
  id              String   @id @default(uuid())
  bot             DCABot  @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId           String
  order           DCABotOrder? @relation(fields: [orderId], references: [id])
  orderId         String?
  
  // Execution Details
  executionType   String   // BUY or SELL
  price           Float    // Execution price
  quantity        Float    // Executed quantity
  fee             Float    @default(0) // Trading fee (for future use)
  
  // Profit Tracking
  profit          Float    @default(0) // Profit from this execution
  cumulativeProfit Float   @default(0) // Total profit up to this execution
  
  // Position Tracking
  baseBalanceAfter  Float   // Base balance after execution
  quoteBalanceAfter Float   // Quote balance after execution
  
  timestamp       DateTime @default(now())
  
  @@index([botId])
  @@index([timestamp])
  @@map("dca_bot_execution")
}